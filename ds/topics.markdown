---
layout: page
title: Project Topics
---

## General info

The project is optional, and it is a way to improve your grade if you did not do well on the midterm,
or just want to get some extra credit.

The project will be due by the end of the semester. 
You will have to make a short (5 minutes) presentation in the last class, showing the work. 
Also, you will have to write a 5-6 page report, describing the problem, 
your solution, and the results obtained.

The project will give you at most 10% of the grade.
I'm not sure about the exact policy, but I will decide and let you know.
In any case, it will be beneficial for your final grade.

We have to discuss the topic of your project, and I have to approve it, before you start working.

Report you progress regularly (for example, once a week), so I can guide you, and you don't waste time.

## Topics

I can suggest a few options. They are not perfect, but you can get an idea:

1. There is a chapter in Rosen's book: Generating Permutations and Combinations (ed7: 6.6)
Implement the algorithms generating all combinations and permutations (in lexicographic order).
Verify that the algorithms work correctly.

2. A maze is stored in a 2-d array of ints so that 0 = wall, 1 = floor. 
There are two special points: entrance and exit.
Write a recursive algorithm silimar to [flood fill](https://en.wikipedia.org/wiki/Flood_fill) 
that finds a path from the entrance to the exit square.
You don't have to generate the maze itself, but maze generation can be intetesting too.

3. Two simple models from computational biology:
[Lotka-Volterra (Predator & Prey model)](https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equation)
and [Repressilator](https://en.wikipedia.org/wiki/Repressilator).

  Both models can be implemented with discrete event simulation, I can help you with it. 
  It is quite similar to stochastic simulation of chemical reactions.
  Not really hard, but requires some interest in biology (or chemistry).

4. Generation of a map, a maze or a building layout using L-systems or a similar model 
that effectively divides space into parts recursively.
Because it is using the Divide and Conquer principle, it is efficient, 
but it can be hard to come up with good rules.

5. Use Prolog for solving logical puzzles like 
[Wolf, goat, cabbage problem](http://jeux.lulu.pagesperso-orange.fr/html/anglais/loupChe/loupChe1.htm)
(If you already know or want to learn Prolog).

6. [SKI](https://en.wikipedia.org/wiki/SKI_combinator_calculus) combinator calculus
is a surprisingly simple Turing-complete language. You have to learn it and
write a program that can reduce (evaluate) expressions of SKI calculus. 
I can explain this topic, if you want to try it. Good programming experience is required.
Better if you know how to work with lists or tuples. A language with garbage collection
should simplify things.

7. *I will update this list and add new topics if I come up with other ideas.*

8. Your topic. Suggest something related to the course. 

### Where to get more ideas

Read Rosen's book, in the end of each chapter, there is a section 
*Computer Projects*, where you can find some ideas.
Also, you can look in the chapters we have not talked about yet (Graphs, Sets, Probability, for example).

Find something that is interesting and seems to be related to the course.

