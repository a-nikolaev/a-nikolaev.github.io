---
layout: page
title: Project Topics
---

## General info

Doing a project is optional,
it is a way to improve your grade if you did not do well on the exams,
or just want to get some extra credit.

All projects will be due by the end of the semester. You will have to:

1. make a short (5-8 minutes) presentation in the last class, showing your work. 
1. Also, you will have to write a 5-6 page report, describing the problem, 
your solution, and the results obtained.

Before you start working on the topic, I have to approve it. 
The topic should be chosen **before** the end of Spring Recess, **April 18**.

**Report you progress regularly (for example, once a week), so I can guide you, and you don't waste time**.

## How to choose a topic

Read Rosen's book, in the end of each chapter, there is a section 
*Computer Projects*, where you can find some ideas.
Also, you can look in the chapters we have not talked about yet (Graphs, Sets, Probability, for example).

Find something that is interesting and seems to be related to the course.

If you can write code, choose a project that requires programming.
We can always find a project that matches your current proficiency in programming.

Try to find something you are interested in, and we will find a way to add some math to make a project out of it.

### New possible topics
1. A simple propositional [satisfiability](https://en.wikipedia.org/wiki/Boolean_satisfiability_problem) solver. 
(A program that checks whether the given compound proposition is satisfiable or not).
1. Programming fractals, [L-systems](https://en.wikipedia.org/wiki/L-system), etc.
1. Another fractal drawing topic: [Context-free art program](http://www.contextfreeart.org/). 
1. Analysis of [social network data](http://snap.stanford.edu/data/). (You will need a specific topic / research goal here).
1. Solving logical puzzles with SMT solvers or Prolog.
1. Experimental analysis of the running time complexity of various standard algorithms.

I will add more topics, but, maybe you already know something
interesting you would like to work on.

### To boost your imagination, the topics from previous semesters:
1. [Sudoku](https://en.wikipedia.org/wiki/Sudoku) solver.
1. Wolfram [cellular automata](http://mathworld.wolfram.com/CellularAutomaton.html).
1. [Maze generation](https://en.wikipedia.org/wiki/Maze_generation_algorithm) with Prim's algorithm.
1. Maze [path finding](http://www.cs.bu.edu/teaching/alg/maze/) algorithm.
1. [Fractals](https://en.wikipedia.org/wiki/Fractal) visualization with OpenGL.
1. [RSA](https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29) enctryption/decryption.
1. Procedural music generation using [ChucK](http://chuck.cs.princeton.edu/).
1. Logical paradoxes (essay).
1. Automatic summarization of texts. 
1. Stochastic simulation of the 
[Predator-Prey](https://alliance.seas.upenn.edu/~ese303/wiki/index.php?n=Main.StochasticSimulationOfChemicalReactions) (Lotka-Volterra) model.
1. Generation of permutations and combinations (described in Rosen, for example).
1. Experimental analysis and Big-O time complexity of [sorting algorithms](https://en.wikipedia.org/wiki/Sorting_algorithm).
1. [Map coloring](https://en.wikipedia.org/wiki/Four_color_theorem) game.
1. Connectivity of random graphs. Giant connected component.
1. Generating large prime numbers.
1. A probabilistic strategy for solving the game Minesweeper.
1. Random graphs. 
  Experimental comparison of [Erdos-Renyi](https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93R%C3%A9nyi_model) and
  [Barabasiâ€“Albert](https://en.wikipedia.org/wiki/Barab%C3%A1si%E2%80%93Albert_model) random graph models.
1. 2048: The best strategy to play the game.
1. Dijkstra's shortest path algorithm.
1. Breaking the [Substitution cipher](https://en.wikipedia.org/wiki/Substitution_cipher) using frequency analysis.
1. [De Bruijn Graphs](https://en.wikipedia.org/wiki/De_Bruijn_graph) and Genome Assembly.
1. [Shortest path algorithms](http://theory.stanford.edu/~amitp/GameProgramming/AStarComparison.html) (A-star and Dijkstra's).
1. Optimality of Change in Currency Systems.
1. [Friendship paradox](https://en.wikipedia.org/wiki/Friendship_paradox). Its verification using [real social network data](http://snap.stanford.edu/data/).
1. Finding the optimal strategy in 5 card draw poker.
1. [Catalan numbers](https://en.wikipedia.org/wiki/Catalan_number) and Gambler's ruin problem.
1. Finding Euler cyles in Eulerian graphs.
1. Implementing [Huffman coding](https://en.wikipedia.org/wiki/Huffman_coding).
1. Graph [coloring](https://en.wikipedia.org/wiki/Graph_coloring).
1. [Dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming).
1. Prime numbers generation.
1. Random word generation with [Markov chains](https://en.wikipedia.org/wiki/Markov_chain#Markov_text_generators).
1. Bioinformatics: [Sequence alignment algorithm](https://en.wikipedia.org/wiki/Sequence_alignment).
1. Solving the [Graceful Tree conjecture](https://en.wikipedia.org/wiki/Graceful_labeling) with
[SMT solvers](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories).

